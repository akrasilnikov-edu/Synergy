# Intro
## 1. Примеры
### ```java code```
```java
package org.senergy;

public class Main {
    public static void main(String[] args) {
        System.out.println("hello");
    }
}


```
### ```c# code```
```csharp
using System;

namespace App
{
    class Program
    {
        static void Main(string[] args)
        {
                Console.WriteLine("Hello");
        }
    }
}

```
### ```python code```
```python
print("hello")
```
## 2. Типы
> Одной из основных особенностей Java является то, что данный язык является строго типизированным. А это значит, что каждая переменная и константа представляет определенный тип и данный тип строго определен. Тип данных определяет диапазон значений, которые может хранить переменная или константа.
> ### Целые числа
> _Все целочисленные значения по умолчанию расцениваются как значения типа int_
>
> ### boolean
>
> ```java
> boolean isActive = true;    //хранит значение true или false
> boolean noActive = false;   //хранит значение true или false
> ```  
> 
> ### byte
> range [`-128 .. 127`] `1 byte`
> 
> ### short 
> range [`-32768 .. 32767`]  `2 byte`
> 
> ### int
> range [`-2147483648 .. 2147483647`] `4 byte`
>
> ```java 
>  int num111 = 0x6F; // 16-теричная система, число 111
>  int num8 = 010; // 8-ричная система, число 8
>  int num13 = 0b1101; // 2-ичная система, число 13
> ```
>
> ### long
> range [`–9223372036854775808 .. –9223372036854775808`]   `8 byte`
> ```java
> long num = 2147483649L;           // суффикс L  указывает, что число представляет тип long
> ```
> ### Числа с плавающей точкой
> При присвоении переменной типа `float` дробного литерала с плавающей точкой, например, 3.1, 4.5 и т.д., Java автоматически рассматривает этот литерал как значение типа `double`. И чтобы указать, что данное значение должно рассматриваться как `float`, нам надо использовать суффикс `f`:
>
> ### double
> range [ `4.9*10^-324 .. ±1.7976931348623157*10^308` ]  `8 byte`
>
> ### float
> range [`-3.4*10^38 .. 3.4*10^38`]  `4 byte`
> ```java
> float fl = 30.6f;             // суффикс f указывает, что число представляет тип float
> ```
>  
> 
> ### Символы и строки
> ### char
> 
> Символьные переменные не стоит путать со строковыми, 'a' не идентично "a"
> 
>>[Unicode](https://symbl.cc/ru/unicode/table/) - Все символы и их коды на одной странице (Общее количество символов: `458 752`)
> ```java
> char ch1 = '\u0646';          // ن Арабская буква нун
> char ch2 = '\u0914';          // औ  Деванагари буква au
> char ch3 = '\u16d2';          // ᛒ Рунический знак berkanan beorc bjarkan b
>``` 
> - - -
> ### var
>  Начиная с Java 10 в язык было добавлено ключевое слово var, которое также позволяет определять переменную:
> ```java 
> var x = 100;
> System.out.println(x);                // 100
> ```
> ```java
> var x;                                // !error  нужна инициализация
> ```  
>  ### final
> Константы позволяют задать такие переменные, которые не должны больше изменяться. Например, если у нас есть переменная для хранения числа pi, то мы можем объявить ее константой, так как ее значение постоянно
> ```java
> final float PI = 3.14f; 
> PI = 6.20;                //PI - контанта, изменить ее не получится
> ``` 
 
## 3. Арифметические и Поразрядные операции
> ## Арифметические
>  - ``/``
> 
> При делении стоит учитывать, что если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной float или double:При делении стоит учитывать, что если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной float или double:
>  ```java
> double k = 5 / 2;                 // числа целые хотя тип double 
> System.out.println(k);            // 2
> 
> double k = 5.0 / 2;               // действия с числом с плавающей точкой
> System.out.println(k);            // 2.5
> ```
> - ### ``%``
> Получение остатка от деления двух чисел:
> ```java 
> int a = 5;
> int b = 2;
> int result = 5 % 2;
> System.out.println(result);           //  1 
> ```  
> ---
> Также есть две унарные арифметические операции, которые производятся над одним числом: ++ (инкремент) и -- (декремент). Каждая из операций имеет две разновидности: префиксная и постфиксная:
> - ### ```++```
> ```java
> int a = 1;
> int b = ++a;                  // префиксный инкремент
> System.out.println(a);        // 2
> System.out.println(b);        // 2
> 
> int a = 3;
> int b = a++;                  // постфиксный инкремент
> System.out.println(a);        // 3
> System.out.println(b);        // 2
> ```
> - ### ```--```
> ```java 
> int a = 8;
> int b = --a;
> System.out.println(a);        // 7
> System.out.println(b);        // 7
> 
> int a = 8; 
> int b = a--;
> System.out.println(a);        // 7
> System.out.println(b);        // 8
> ```  
> ## Поразрядные
>  Каждое число имеет определенное двоичное представление. Например, число ``4`` в двоичной системе ``100``, а число ``5`` - ``101`` и так далее.
> 
> К примеру, возьмем следующие переменные:
> ```java
> byte b = 7;     // 0000 0111                  // 1 byte (8 bit)
> short s = 7;    // 0000 0000 0000 0111        // 2 byte (16 bit)
> ``` 
> ### Логические операции
> - `&` (логическое умножение)  
>Умножение производится поразрядно, и если у обоих операндов значения разрядов равно 1, то операция возвращает 1, иначе возвращается число 0. Например:
> ```java
> int a = 2;            // 010 
> int b = 5;            // 101
> System.out.println(a & b); // результат 0
>
> int a1 = 4;           // 100
> int b1 = 5;           // 101
> System.out.println(a1 & b1); // результат 4
> ```
> - `|` (логическое сложение)   
> Данная операция также производится по двоичным разрядам, но теперь возвращается единица, если хотя бы у одного числа в данном разряде имеется единица (операция "логическое ИЛИ"). Например:
> ```java
> int a1 = 2;           // 010
> int b1 = 5;           // 101
> System.out.println(a1|b1); // результат 7  (0111)
> 
> int a2 = 4;           // 100
> int b2 = 5;           // 101 
> System.out.println(a2 | b2); // результат 5  (0101)
>```
> 
>  - `^` (логическое исключающее ИЛИ)  
> Также эту операцию называют XOR, нередко ее применяют для простого шифрования:
> ```java 
> int number = 45;              // 1001 Значение, которое надо зашифровать - в двоичной форме 101101
> int key = 102;                //Ключ шифрования - в двоичной системе 1100110
> int encrypt = number ^ key;   //Результатом будет число 1001011 или 75
> System.out.println("Зашифрованное число: " + encrypt);
> 
> int decrypt = encrypt ^ key;   // Результатом будет исходное число 45
> System.out.println("Расшифрованное число: " + decrypt);
>```
> - `~` (логическое отрицание)  
> Поразрядная операция, которая инвертирует все разряды числа: если значение разряда равно 1, то оно становится равным нулю, и наоборот.
> ```java 
>  byte a = 12;                 // 0000 1100
>  System.out.println(~a);      //  1111 0011   или -13
> ```
> ### Операции сдвига
>Операции сдвига также производятся над разрядами чисел. Сдвиг может происходить вправо и влево
> -  ``a<<b`` сдвигает число a влево на b разрядов. Например, выражение 4<<1 сдвигает число 4 (которое в двоичном представлении 100) на один разряд влево, в результате получается число 1000 или число 8 в десятичном представлении.
>
> 
> -  ``a>>b`` смещает число a вправо на b разрядов. Например, 16>>1 сдвигает число 16 (которое в двоичной системе 10000) на один разряд вправо, то есть в итоге получается 1000 или число 8 в десятичном представлении.
> 
## 4. Условные выражения
> Условные выражения представляют собой некоторое условие и возвращают значение типа boolean, то есть значение true (если условие истинно), или значение false (если условие ложно). К условным выражениям относятся операции сравнения и логические операции.
>  ### Операции сравнения
> В операциях сравнения сравниваются два операнда, и возвращается значение типа boolean - true, если выражение верно, и false, если выражение неверно.
>- ``==`` 
>сравнивает два операнда на равенство и возвращает true (если операнды равны) и false (если операнды не равны)
> ```java
> int a = 10;
> int b = 4;
> boolean c = a == b;         // false
> boolean d = a == 10;        // true
> 
> ```
>
>-  ``!=``
>сравнивает два операнда и возвращает true, если операнды НЕ равны, и false, если операнды равны
> ```java
> int a = 10;
> int b = 4;
> boolean c = a != b;         // true
> boolean d = a != 10;        // false
> ```
>
>- ``<`` (меньше чем)
>Возвращает true, если первый операнд меньше второго, иначе возвращает false
> ```java
> int a = 10;
> int b = 4;
> boolean c = a < b;           // false
> ```
>
> - ``>`` (больше чем)
> Возвращает true, если первый операнд больше второго, иначе возвращает false
> ```java 
> int a = 10; 
> int b = 4;
> boolean c = a > b;   // true
> ```
> 
> - ``=`` (больше или равно)
> Возвращает true, если первый операнд больше второго или равен второму, иначе возвращает false
> ```java 
> boolean c = 10 >= 10;    // true
> boolean b = 10 >= 4;     // true
> boolean d = 10 >= 20;    // false
> ``` 
>
> - ``<=`` (меньше или равно)
> Возвращает true, если первый операнд меньше второго или равен второму, иначе возвращает false
>```java
> boolean c = 10 <= 10;    // true
> boolean b = 10 <= 4;     // false
> boolean d = 10 <= 20;    // true
>``` 
>
> ### Логические операции
> Также в Java есть логические операции, которые также представляют условие и возвращают true или false и обычно объединяют несколько операций сравнения. К логическим операциям относят следующие:
>> - ``|``
>>    c=a|b; (c равно true, если либо a, либо b (либо и a, и b) равны true, иначе c будет равно false)
>>-  ``&``
>>    c=a&b; (c равно true, если и a, и b равны true, иначе c будет равно false)
>>-    ``!``
>>    c=!b; (c равно true, если b равно false, иначе c будет равно false)
>>-    ``^``
>>    c=a^b; (c равно true, если либо a, либо b (но не одновременно) равны true, иначе c будет равно false)
>>-    ``||``
>>    c=a||b; (c равно true, если либо a, либо b (либо и a, и b) равны true, иначе c будет равно false)
>>-    ``&&``
>>    c=a&&b; (c равно true, если и a, и b равны true, иначе c будет равно false)
> ____
> ### Операции присваивания
>> -   ``=`` 
>   просто приравнивает одно значение другому: c=b;
>> -  ``+=`` 
>  c+=b; (переменной c присваивается результат сложения c и b)
>> -   ``-=`` 
>    c-=b; (переменной c присваивается результат вычитания b из c)
>> -   ``*=`` 
>    c*=b; (переменной c присваивается результат произведения c и b)
>> -   ``/=`` 
>>    c/=b; (переменной c присваивается результат деления c на b)
>> -   ``%=`` 
>    c%=b; (переменной c присваивается остаток от деления c на b)
>> -   ``&=`` 
>    c&=b; (переменной c присваивается значение c&b)
>> -   ``|=`` 
>    c|=b; (переменной c присваивается значение c|b)
>> -   ``^=`` 
>    c^=b; (переменной c присваивается значение c^b)
>>  -  ``<<=`` 
>    c<<=b; (переменной c присваивается значение c<<b)
>> -   ``>>=`` 
>    c>>=b; (переменной c присваивается значение c>>b)
> 
## 5. Условные операторы
> В языке Java используются следующие условные конструкции: ``if..else`` и ``switch..case``
> ### if/else
>> Выражение ``if/else`` проверяет истинность некоторого условия и в зависимости от результатов проверки выполняет определенный код:
> ```java
> >>>  if(logical_expression){
> >>>      some_operation();
> >>>  }else{
> >>>      other_operation();
> >>>  }
>```
> Но при сравнении чисел мы можем насчитать три состояния: первое число больше второго, первое число меньше второго и числа равны. С помощью выражения `else if`, мы можем обрабатывать дополнительные условия:
> ````java
> int num1 = 0;
> int num2 = 1;
> if(num1>num2){
>       System.out.println("Первое число больше второго");
> }
> else if(num1<num2){
>       System.out.println("Первое число меньше второго");
> }
> else{
>       System.out.println("Числа равны");
> }
>````
> ### switch/case
>>Конструкция ``switch/case`` аналогична конструкции ``if/else``, так как позволяет обработать сразу несколько условий:
> ```java
> Scanner sc = new Scanner(System.in);
> int operator = sc.nextInt();
> String output;
> switch (operator) {
>       case 1 -> output = "1";
>       case 2, 4 -> output = "2,4";
>       case 3  -> output = "2";
>       default:
>               output = "None";
> }
> System.out.println(output);
> ```
> В конце блока `сase` ставится оператор `break`, чтобы избежать выполнения других блоков. 
## 6. Преобразования базовых типов
> Каждый базовый тип данных занимает определенное количество байт памяти. Это накладывает ограничение на операции, в которые вовлечены различные типы данных. Рассмотрим следующий пример:
> ```java
> int a = 4;
> byte b = a;       // ! Ошибка
>```
> В данном коде мы столкнемся с ошибкой. Хотя и тип byte, и тип int представляют целые числа. Более того, значение переменной `a`, которое присваивается переменной типа byte, вполне укладывается в диапазон значений для типа byte (от -128 до 127). Тем не менее мы сталкиваемся с ошибкой на этапе компиляции. Поскольку в данном случае мы пытаемся присвоить некоторые данные, которые занимают 4 байта, переменной, которая занимает всего один байт.
> 
> Тем не менее в программе может потребоваться, чтобы подобное преобразование было выполнено. В этом случае необходимо использовать операцию преобразования типов (операция `()`):
>```java
>int a = 4;
>byte b = (byte)a;      // преобразование типов: от типа int к типу byte
>System.out.println(b); // 4
>``` 
> Операция преобразования типов предполагает указание в скобках того типа, к которому надо преобразовать значение. Например, в случае операции `(byte)a`, идет преобразование данных типа int в тип byte. В итоге мы получим значение типа byte.  
> ### Явные и неявные преобразования
> Когда в одной операции вовлечены данные разных типов, не всегда необходимо использовать операцию преобразования типов. Некоторые виды преобразований выполняются неявно, автоматически.  
> #### Автоматические преобразования
>```mermaid
> graph LR 
>                             c(char) --> i
>    b(byte) --> s(short) --> i(int) --> l(long) --->|loss of precision|d
>    i -->|loss of precision|f(float)
>                            f--> d(double)
>                            i -->|loss of precision|d
>    
>``` 
> Стрелками на рисунке показано, какие преобразования типов могут выполняться автоматически
> 
> Автоматически без каких-либо проблем производятся *расширяющие преобразования* (widening) - они расширяют представление объекта в памяти. Например:
> ```java
> byte b = 7;
> int d = b;  // преобразование от byte к int
> ```
>В данном случае значение типа byte, которое занимает в памяти 1 байт, расширяется до типа int, которое занимает 4 байта.
> ### Явные преобразования
> Во всех остальных преобразованиях примитивных типов явным образом применяется операция преобразования типов. Обычно это сужающие преобразования (narrowing) от типа с большей разрядностью к типу с меньшей разрядностью:
> ```java 
> long a = 4;
> int b = (int) a;
> ```
> ### Потеря данных при преобразовании
> При применении явных преобразований мы можем столкнуться с потерей данных. Например, в следующем коде у нас не возникнет никаких проблем:
> ```java
> int a = 5;
> byte b = (byte) a;
> System.out.println(b);      // 5 
>```
> Число 5 вполне укладывается в диапазон значений типа byte, поэтому после преобразования переменная b будет равна 5. Но что будет в следующем случае:
> ```java
> int a = 258;
> byte b = (byte) a; 
> System.out.println(b);      // 2 
> //                                В данном случае число 258 вне диапазона для типа byte (от -128 до 127), поэтому произойдет усечение значения
>``` 
> Число a, которое равно 258, в двоичной системе будет равно 00000000 00000000 00000001 00000010. Значения типа byte занимают в памяти только 8 бит. Поэтому двоичное представление числа int усекается до 8 правых разрядов, то есть 00000010, что в десятичной системе дает число 2.
> 
> ### Преобразования при операциях
> Нередки ситуации, когда приходится применять различные операции, например, сложение и произведение, над значениями разных типов. Здесь также действуют некоторые правила:
> 
> - если один из операндов операции относится к типу double, то и второй операнд преобразуется к типу double
> - если предыдущее условие не соблюдено, а один из операндов операции относится к типу float, то и второй операнд преобразуется к типу float
> - если предыдущие условия не соблюдены, один из операндов операции относится к типу long, то и второй операнд преобразуется к типу long
> - иначе все операнды операции преобразуются к типу int
> 
> Если в операциях участвуют данные типа char, то они преобразуются в int:
> ```java
> int d = 'a' + 5;
> System.out.println(d);  // 102
> 
>```
 
 ## 7. Методы
> Если переменные и константы хранят некоторые значения, то методы содержат собой набор операторов, которые выполняют определенные действия.      
>``` 
> [modifiers...] type methodName([options...]){
>       // method body
> }
>``` 
> Вызов метода осуществляется в форме:
> ```java
> public class Program{
>    static void hello(){
>         
>        System.out.println("Hello");
>    }
> 
>    static void welcome(){
>         
>        System.out.println("Welcome to Java 10");
>    }
> 
>    public static void main (String args[]){
>          
>         hello();
>         welcome();
>         welcome();
>    }
>
> }
> ```
> ### Параметры методов
> С помощью параметров мы можем передать в методы различные данные, которые будут использоваться для вычислений. Например:
> ```java
> static void sum(int x, int y){
>
>    int z = x + y;
>    System.out.println(z);
> }
>```
> А при вызове этого метода в программе нам необходимо передать на место параметров значения, которые соответствуют типу параметра:
> ```java
> public class Program{
>
>    static void sum(int x, int y){
>         
>        int z = x + y;
>        System.out.println(z);
>    }
>      
>    public static void main (String args[]){
>          
>        int a = 6;
>        int b = 8;
>        sum(a, b);  // 14
>        sum(3, a);  // 9
>        sum(5, 23); // 28
>    }    
> }
>``` 
> ### Параметры переменной длины 
> Метод может принимать параметры переменной длины одного типа. Например, нам надо передать в метод набор числел и вычислить их сумму, но мы точно не знаем, сколько именно чисел будет передано - 3, 4, 5 или больше. Параметры переменной длины позволяют решить эту задачу:
> ```java
> public class Program{
> 
>    static void sum(int ...nums){         
>        int result =0;
>        for(int n: nums)
>            result += n;
>        System.out.println(result);
>    }
>      
>    public static void main (String args[]){
>          
>        sum(1, 2, 3);           // 6
>        sum(1, 2, 3, 4, 5);     // 15
>        sum();                  // 0
>    }
>
> }
> ```
> ### Перегрузка методов
> В программе мы можем использовать методы с одним и тем же именем, но с разными типами и/или количеством параметров. Такой механизм называется перегрузкой методов (method overloading).
> ```java
> public class Program{
>    static int sum(int x, int y){
>             
>        return x + y;
>    }
>    static double sum(double x, double y){
>             
>        return x + y;
>    }
>    static int sum(int x, int y, int z){
>             
>        return x + y + z;
>    }
>      
>    public static void main(String[] args) {
>         
>        System.out.println(sum(2, 3));          // 5
>        System.out.println(sum(4.5, 3.2));      // 7.7
>        System.out.println(sum(4, 3, 7));       // 14
>    }
>
> }
>```

> ## 8. Введение в обработку исключений
> 
> Нередко в процессе выполнения программы могут возникать ошибки, при том необязательно по вине разработчика. Некоторые из них трудно предусмотреть или предвидеть, а иногда и вовсе невозможно. Так, например, может неожиданно оборваться сетевое подключение при передаче файла. Подобные ситуации называются исключениями.
>
>В языке Java предусмотрены специальные средства для обработки подобных ситуаций. Одним из таких средств является конструкция `try...catch...finally`. При возникновении исключения в блоке try управление переходит в блок catch, который может обработать данное исключение. Если такого блока не найдено, то пользователю отображается сообщение о необработанном исключении, а дальнейшее выполнение программы останавливается. И чтобы подобной остановки не произошло, и надо использовать блок `try..catch`. Например:
> ```java
> try{
>       int[] numbers = new int[3];
>       numbers[4]=45;
>       System.out.println(numbers[4]);
> }
> catch(Exception ex){ 
>       ex.printStackTrace(); 
> }
> System.out.println("Программа завершена");
>```
> При использовании блока `try...catch` вначале выполняются все инструкции между операторами `try и catch`. Если в блоке `try` вдруг возникает исключение, то обычный порядок выполнения останавливается и переходит к инструкции `сatch`. Поэтому когда выполнение программы дойдет до строки `numbers[4]=45;`, программа остановится и перейдет к блоку `catch`
>
> Выражение `catch` имеет следующий синтаксис: `catch (тип_исключения имя_переменной)`. В данном случае объявляется переменная `ex`, которая имеет тип `Exception`. Но если возникшее исключение не является исключением типа, указанного в инструкции `сatch`, то оно не обрабатывается, а программа просто зависает или выбрасывает сообщение об ошибке.
>
> Но так как тип `Exception` является базовым классом для всех исключений, то выражение `catch (Exception ex)` будет обрабатывать практически все исключения. Обработка же исключения в данном случае сводится к выводу на консоль стека трассировки ошибки с помощью метода `printStackTrace()`, определенного в классе `Exception`.
>
> После завершения выполнения блока `catch` программа продолжает свою работу, выполняя все остальные инструкции после блока `catch`.
>
> Конструкция `try..catch` также может иметь блок `finally`. Однако этот блок необязательный, и его можно при обработке исключений опускать. Блок `finally` выполняется в любом случае, возникло ли исключение в блоке `try` или нет
> 

---
```end```
